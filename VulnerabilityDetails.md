### Summary
A race condition was found in the way the Linux kernel's memory subsystem handled the copy-on-write (COW) breakage of private read-only memory mappings. All the information we have so far is included in this page.

### Impact
* An unprivileged local user could use this flaw to gain write access to otherwise read-only memory mappings and thus increase their privileges on the system.
* This flaw allows an attacker with a local system account to modify on-disk binaries, bypassing the standard permission mechanisms that would prevent modification without an appropriate permission set. 

### How
* The In The Wild exploit relied on writing to /self/proc/mem on one side of the race.
* The In The Wild exploit relied on using ptrace.
* The attack relies on racing the madvise(MADV_DONTNEED) system call while having the page of the executable mmapped in memory.

### Commit messages

commit 4ceb5db9757aaeadcf8fbbf97d76bd42aa4df0d6  
Author: Linus Torvalds <torvalds@g5.osdl.org>  
Date:   Mon Aug 1 11:14:49 2005 -0700  

    Fix get_user_pages() race for write access
    
    There's no real guarantee that handle_mm_fault() will always be able to
    break a COW situation - if an update from another thread ends up
    modifying the page table some way, handle_mm_fault() may end up
    requiring us to re-try the operation.
    
    That's normally fine, but get_user_pages() ended up re-trying it as a
    read, and thus a write access could in theory end up losing the dirty
    bit or be done on a page that had not been properly COW'ed.
    
    This makes get_user_pages() always retry write accesses as write
    accesses by making "follow_page()" require that a writable follow has
    the dirty bit set.  That simplifies the code and solves the race: if the
    COW break fails for some reason, we'll just loop around and try again.

commit 19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Thu Oct 13 20:07:36 GMT

    There's no real guarantee that handle_mm_fault() will always be able to
    break a COW situation - if an update from another thread ends up
    modifying the page table some way, handle_mm_fault() may end up
    requiring us to re-try the operation.

    That's normally fine, but get_user_pages() ended up re-trying it as a
    read, and thus a write access could in theory end up losing the dirty
    bit or be done on a page that had not been properly COW'ed.

    This makes get_user_pages() always retry write accesses as write
    accesses by making "follow_page()" require that a writable follow has
    the dirty bit set.  That simplifies the code and solves the race: if the
    COW break fails for some reason, we'll just loop around and try again.

### References
* https://bugzilla.redhat.com/show_bug.cgi?id=1384344
* https://access.redhat.com/security/vulnerabilities/2706661